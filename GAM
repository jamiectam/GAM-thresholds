cc<-CCIEA.Reference.Points.Workshop.Ecological.Integrity.and.Human.Activities.indicator.time.series

##coastwide data
ccALL <- cc[cc$Coastwide == 1,]

ccdat<-ccALL[,c("year", "value", "timeseries")]

ts.length<-c(2003:2012)

ccind<-ccdat[ccdat$timeseries %in% c("GF_spp_richness_coastwide", "GF-Simp_coastwide", "GF_MTL_coastwide", "Scav_ratio"),]
names(ccind)[1]<-paste("YEAR")
names(ccind)[2]<-paste("VALUE")
names(ccind)[3]<-paste("INDICATOR")
indicator<-ccind

ccdri<-ccdat[! ccdat$timeseries %in% c("GF_spp_richness_coastwide", "GF-Simp_coastwide", "GF_MTL_coastwide", "Scav_ratio"),]
names(ccdri)[1]<-paste("YEAR")
names(ccdri)[2]<-paste("VALUE")
names(ccdri)[3]<-paste("DRIVER")
driver<-ccdri[ccdri$YEAR %in% ts.length,]

ind.name<-unique(as.character(indicator$INDICATOR))
dri.name<-unique(as.character(driver$DRIVER))

name.grid<-expand.grid(ind.name, dri.name)
table.list<-paste(name.grid$Var1,name.grid$Var2, sep=".")

for (d in 1:length(dri.name)){
  for (i in 1:length(ind.name)){
    driver.d<-subset(driver, DRIVER %in% dri.name[d])
    driver.yr<-driver.d$YEAR
    
    indicator.i<-subset(indicator, INDICATOR %in% ind.name[i]) 
    indicator.NA<-subset(indicator.i, VALUE != "NA")
    indicator.i<-subset(indicator.NA, YEAR %in% driver.yr)
    indicator.yr<-indicator.i$YEAR
    
    driver.d<-subset(driver.d, YEAR %in% indicator.yr)
    
    driver.indicator.di<-cbind(driver.d$YEAR,indicator.i$VALUE,driver.d$VALUE)
    colnames(driver.indicator.di)<-c("YEAR",ind.name[i],dri.name[d])
    assign(paste(ind.name[i],dri.name[d], sep="."), driver.indicator.di)

  }
}

gam.value<-data.frame()
for (i in 1:length(table.list)) {
  # prev<-progressBar(i/length(table.list),prev)
  table<-get(table.list[i])         #
  response.name<-colnames(table)[2]
  driver.name<-colnames(table)[3] 
  myresponse<-table[,2]
  mydriver<-table[,3]
  ts.length<-table[,1]
}
#####################
# Fit the GAM model #
#####################

set.seed(1122)
sp.len<-200 # Spline length
nb <- 1000  # Bootstrap length
thresh <- matrix(nrow=sp.len, ncol=nb) ## create a matrix to be filled with bootstrapped splines (200 x 1000)
dif1<- 1 ## Adjust which difference to take
dif2<- 2


gam1<-gam(myresponse~s(mydriver, bs="ts"), method="GCV.Cp", se=T)
gam2<-gam(myresponse~mydriver, method="GCV.Cp", se=T)


assign(paste(table.list[i], "GAM", sep="."), gam1)
assign(paste(table.list[i], "LIN", sep="."), gam2)

value.i<-as.data.frame(cbind(summary(gam1)$dev.expl,summary(gam1)$edf, summary(gam1)$sp.criterion, summary(gam1)$s.pv))   
value.i<-cbind(table.list[i], "Smoother", as.data.frame(value.i))
colnames(value.i)<-c("data","model","dev.expl","edf", "GCV", "p_value")

lin.i<-as.data.frame(cbind(summary(gam2)$dev.expl,NA, summary(gam2)$sp.criterion, summary(gam2)$p.pv[2]))
lin.i<-cbind(table.list[i], "Linear", lin.i)
colnames(lin.i)<-c("data","model","dev.expl","edf", "GCV", "p_value")

gam.value<-rbind(gam.value,value.i, lin.i)



# Collect the GAM models that are significant... or at least work)    
na.sig.list<-as.character(gam.value$data[is.na(gam.value$p_value)])
sig.data<-gam.value[!is.na(gam.value$p_value),]
sig.smoother<-sig.data[sig.data$model=="Smoother",]


# Only excludes GAM models that yield <NA> results
# sig.list<-paste(gam.value$data[!is.na(gam.value$p_value)], "GAM", sep=".")
sig.list<-paste(sig.smoother$data[sig.smoother$p_value<0.05], "GAM", sep=".")
     

# Check models
for (g in 1:length(sig.list)) {
  #  
  resid.plot<-paste(model.dir, sig.list[g],"_rsd",".pdf", sep="")
  pdf(file=resid.plot)  
  plot.gam((get(sig.list[g])), residuals=T, pages=1, pch=19)
  dev.off()
  check.plot<-paste(model.dir, sig.list[g],"_chk",".pdf", sep="")
  pdf(file=check.plot)
  gam.check(get(sig.list[g]), old.style=T)
  dev.off()
}

  write.csv(gam.value, "cc_GAM_results.csv", row.names=F)


# Get the spline for the significant GAM models

for (g in 1:length(sig.list)) {
  gam.table<-get(sig.list[g]) #
  gam.driver<-as.data.frame(get(gsub(".GAM","",sig.list[g])))[,3] #
  pred<-predict.gam(gam.table, se.fit=T)
  fds <- cbind(pred$fit,gam.driver,pred$se.fit)
  fds2 <- order(fds[,2])
  response <- spline(pred$fit[fds2]~gam.driver[fds2],n=sp.len)
  gam.data <- as.data.frame(cbind(response$y,response$x))
  colnames(gam.data)<-c("response","driver")
  assign(paste(sig.list[g], "DATA", sep="."), gam.data)
}

#Bootstrap

for (g in 1:length(sig.list)) {
  sig<-get(paste(sig.list[g], "DATA", sep="."))#
  boot.data<-as.data.frame(get(gsub(".GAM","",sig.list[g])))#
  response.g<-boot.data[,2]
  driver.g<-boot.data[,3]
  year.g<-boot.data[,1]
  for (b in 1:nb) {
    bootsample <- sample(1:length(year.g), replace=T)
    myresponsei <- response.g[bootsample]
    mydriveri <- driver.g[bootsample]
    #######Computing threshold on new sample #######
    gam.object <- gam(myresponsei~s(mydriveri, bs="tp"),method="GCV.Cp", na.action='na.omit')
    prediction <- predict.gam(gam.object, se.fit=T)
    fds <- cbind(prediction$fit,mydriveri,prediction$se.fit,0,0)
    fds2 <- order(fds[,2])
    titu <- spline(prediction$fit[fds2]~mydriveri[fds2],n=sp.len)
    data <- cbind(titu$y,titu$x)
    thresh[,b]<- titu$y
    assign(paste(sig.list[g],"MATRIX",sep="."), thresh)
  }
  
  
  #######################
  # CI of GAM bootstrap #
  #######################
  
  ci<-matrix(nrow= 2, ncol= sp.len) ## create a matrix to be filled with bootstrapped CI
  rownames(ci)<-c("lower","upper")
  for (gam.ci in 1:sp.len) {
    IC<-quantile(thresh[gam.ci,], c(0.025, 0.975))
    ci[,gam.ci]<-rbind(IC[1], IC[2])
    assign(paste(sig.list[g],"CI", sep="."), ci)
  }
  
  #############################
  # 1st Derivative Estimation #
  #############################
  dif1.line<-diff(gam.data$response, difference=1) # Actual 1st deriv estimate from original smoother
  deriv.matrix.1<-matrix(nrow=sp.len-dif1, ncol=nb) ## create a matrix to for the 1st deriv estimates
  for (first in 1:nb) {
    derivi<-thresh[,first]
    deriv.response<-diff(derivi, difference=dif1)
    driver.len<-length(mydriver)-dif1
    deriv.object <- cbind(deriv.response,driver.len)
    deriv.matrix.1[,first]<-deriv.object[,1]
    assign(paste(sig.list[g],"MATRIX.1",sep="."), deriv.matrix.1)
    assign(paste(sig.list[g],"dif1.line", sep="."), dif1.line)
  }
  
  
  # CI of 1st derivative 
  dif1.len<-sp.len-dif1
  ci1<-matrix(nrow= 2, ncol= dif1.len) ## create a matrix to be filled with bootstrapped CI
  rownames(ci1)<-c("lower","upper")

  for (first.ci in 1:dif1.len) {
    IC<-quantile(deriv.matrix.1[first.ci,], c(0.025, 0.975))
    ci1[,first.ci]<-rbind(IC[1], IC[2])
    assign(paste(sig.list[g], "CI.1", sep="."), ci1)

  }
  
  #############################
  # 2nd Derivative Estimation #
  #############################
  dif2.line<-diff(gam.data$response, difference=2) # Actual 2nd deriv estimate from original smoother
  deriv.matrix.2<-matrix(nrow=sp.len-dif2, ncol=nb) ## create a matrix to for the 2nd deriv estimates
  for (second in 1:nb) {
    derivi<-thresh[,second]
    deriv.response<-diff(derivi, difference=dif2)
    driver.len<-length(mydriver)-dif2
    deriv.object <- cbind(deriv.response,driver.len)
    deriv.matrix.2[,second]<-deriv.object[,1]
    assign(paste(sig.list[g], "MATRIX.2",sep="."), deriv.matrix.2)
    assign(paste(sig.list[g],"dif2.line", sep="."), dif2.line)
  }
  
  # CI of 2nd derivative 
  dif2.len<-sp.len-dif2
  ci2<-matrix(nrow= 2, ncol= dif2.len) ## create a matrix to be filled with bootstrapped CI
  rownames(ci2)<-c("lower","upper")

  for (second.ci in 1:dif2.len) {
    IC<-quantile(deriv.matrix.2[second.ci,], c(0.025, 0.975))
    ci2[,second.ci]<-rbind(IC[1], IC[2])
    assign(paste(sig.list[g], "CI.2",sep="."), ci2)

  }
  
  # CI of response
  lower <- min(ci[1,  ])
  upper <- max(ci[2,  ])
  lower1 <- min(ci1[1,  ])
  upper1 <- max(ci1[2,  ])
  lower2 <- min(ci2[1,  ])
  upper2 <- max(ci2[2,  ])
  
  CI.table<-matrix(nrow=2, ncol=3, data=c(upper,
                                          lower,
                                          upper1,
                                          lower1,
                                          upper2,
                                          lower2),
                   dimnames=list(c("UPPER", "LOWER"),
                                 c("GAM","FIRST","SECOND")))          
  assign(paste(sig.list[g],"CI.matrix",sep="."), CI.table)
  

  
}   
